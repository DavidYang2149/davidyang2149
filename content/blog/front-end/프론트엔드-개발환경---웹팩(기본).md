---
title: 프론트엔드 개발환경 - 웹팩(기본)
date: 2020-09-08 10:09:08
category: front-end
thumbnail: './images/200908-webpack-icon.png'
draft: false
---

![](./images/200908-webpack-icon.png)

프론트엔드 개발환경 - 웹팩(기본)

> `정보` : [**김정환**](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)님의 [프론트엔드 개발환경의 이해와 실습](https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD)을 공부하고 정리한 내용.

# 1. 배경 🚀

Javascript로 개발을 할 때 모듈의 필요성과 한계가 나타나고 그에 따라 웹팩(Webpack)이 등장하게 되었다.

```js{}
function sum(a, b) {
  return a + b;
} // 전역 공간에 sum이 노출

sum(1, 2); // 결과는 3

sum = 3;
sum(1, 2); // Uncaught TypeError: sum is not a function
```

상단처럼 전역(Global)에서 설정된 변수의 내용이 임의로 변하는 것을 막기 위한 방법이 필요했다.

## 1.1. IIFE 방식의 모듈

[IIFE](https://developer.mozilla.org/ko/docs/Glossary/IIFE)(즉시 실행 함수 표현)는 즉시 함수를 실행하여 외부에서 접근을 막는 함수이다.

```js{}
var math = math || {}; // math 네임스페이스

(function () {
  function sum(a, b) {
    return a + b;
  }
  math.sum = sum; // 네이스페이스에 추가
})();

math.sum(1, 2); // 결과는 3

sum(1, 2); // Uncaught TypeError: sum is not a function
```

## 1.2. 다양한 모듈 스펙

자바스크립트의 모듈을 구현하는 대표적인 명세는 [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)와 [CommonJS](http://www.commonjs.org)가 있다.

그리고 ES2015에서 [표준 모듈 시스템](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)이 나오게 되었다.

./math.js

```js{}
export function sum(a, b) {
  return a + b;
}
```

./app.js

```js{}
import * as math from './math.js';
math.sum(1, 2); // 3
```

문제는 모든 브라우저에서 이 모듈 기능을 지원하지 않는다는 것이다 😱.

# 2. 웹팩(Webpack) 📦

웹팩은 여러개의 파일을 하나로 합쳐주는 번들러(bundler)다.

그럼 webpack을 설치해보자.

```sh{}
$ npm install -D webpack webpack-cli
```

webpack을 설치한 후에 옵션을 보자.

```sh{}
# node_modules/.bin/webpack --help를 입력하면 정보를 알 수 있다.
$ node_modules/.bin/webpack --help

  --mode                 Enable production optimizations or development hints.
                                     [선택: "development", "production", "none"]
  --entry      The entry point(s) of the compilation.                   [문자열]
  --output, -o                  The output path and file for compilation assets
```

여기서 `--mode`, `--entry`, `--output` 세 개 옵션만 사용하면 코드를 묶을 수 있다.

```sh{}
$ node_modules/.bin/webpack --mode development --entry ./src/app.js --output dist/main.js
```

- `--mode`는 웹팩 실행 모드는 의미하는데 개발 버전인 development를 지정한다.
- `--entry`는 시작점 경로를 지정하는 옵션이다.
- `--output`은 번들링 결과물을 위치할 경로다.

위 명령어를 실행하면 dist/main.js에 번들된 결과가 저장된다.

```sh{}
> lecture-frontend-dev-env@1.0.0 build /Users/davidyang/Documents/lecture-frontend-dev-env
> webpack

Hash: 5610665b6c989a4f05ee
Version: webpack 4.44.1
Time: 97ms
Built at: 2020-09-08 16:04:38
  Asset      Size  Chunks             Chunk Names
main.js  19.9 KiB    main  [emitted]  main
Entrypoint main = main.js
[./src/app.js] 145 bytes {main} [built]
```

그리고 index.html에 로딩하면 번들링의 결과와 동일하게 된다.

```html{}
<script src="dist/main.js"></script>
```

또한 `webpack.config.js`를 생성해 사용할 수 있다.

```js{}
const path = require('path');

module.exports = {
  mode: 'development',
  entry: {
    main: './src/app.js',
  },
  output: {
    filename: '[name].js',
    path: path.resolve('./dist'),
  },
};
```

그리고 `package.json`에 명령어를 추가한다.

```json{}
{
  "scripts": {
    "build": "./node_modules/.bin/webpack"
    //"build": "webpack" // 이렇게 해도 된다.
  }
}
```

이제 터미널에 **npm run build**로 webpack을 실행할 수 있다.

```sh{}
$ npm run build
```

이후 마찬가지로 index.html에 로딩하면 된다.

# 3. 로더 🔋

웹팩은 모든 파일을 모듈로 관리하는데 이미지, 폰트, 스타일시트도 모두 모듈로 관리한다.

웹팩은 자바스크립트 밖에 인식할 수 없기 때문에 이미지, 폰트, 스타일시트를 웹팩이 이해할 수 있도록 변경시켜야 한다.

로더가 바로 이 역할을 한다.

## 3.1. 로더의 역할

로더는 타입스크립트 같은 다른 언어를 자바스크립트 문법으로 변환해 주거나 이미지를 data URL 형식의 문자열로 변환한다.

뿐만아니라 CSS 파일을 자바스크립트에서 직접 로딩할수 있도록 해준다.

## 3.2. 커스텀 로더 만들기

커스텀으로 로더를 만들어 보자.

./myloader.js

```js{}
module.exports = function myloader(content) {
  console.log('myloader 테스트');
  return content;
};
```

커스텀 로더를 제작한 후에 웹팩 설정파일의 module 객체에 추가한다.

./webpack.config.js

```js{}
module: {
  rules: [{
    test: /\.js$/, // .js 확장자로 끝나는 모든 파일.
    use: [path.resolve('./myloader.js')] // 방금 만든 로더를 적용한다.
  }],
}
```

module.rules 배열에 모듈을 추가하는데 test와 use로 구성된 객체를 전달한다.

test에는 로딩에 적용할 파일을 지정한다.

use에는 패턴에 해당하는 파일에 적용할 로더를 설정하는 부분으로 방금 만든 myloader 함수의 경로를 지정한다.

`npm run build`을 실행해보자.

```sh{}
$ npm run build

> lecture-frontend-dev-env@1.0.0 build /Users/davidyang/Documents/lecture-frontend-dev-env
> webpack

myloader 테스트
Hash: 5610665b6c989a4f05ee
Version: webpack 4.44.1
Time: 115ms
Built at: 2020-09-09 23:16:09
  Asset      Size  Chunks             Chunk Names
main.js  19.9 KiB    main  [emitted]  main
Entrypoint main = main.js
[./src/app.js] 145 bytes {main} [built]
```

터미널에 myloader 테스트' 문자열이 찍힌다.

myloader() 함수가 동작했다.

# 4. 자주 사용하는 로더

자주 사용하는 로더를 확인해보자.

## 4.1. css-loader

웹팩에 css-loader를 추가하여 모듈로 변환한다.

./app.js

```js{}
import './style.css';
```

./style.css

```css{}
body {
  background-color: green;
}
```

CSS 파일을 자바스크립트에서 불러와 사용할 수 있게 CSS를 모듈로 변환해보자.

css-loader를 설치하자.

```sh{}
npm install -D css-loader
```

웹팩 설정에 로더를 추가한다.

./webpack.config.js:

```js{}
module.exports = {
  module: {
    rules: [
      {
        test: /\.css\$/, // .css 확장자로 끝나는 모든 파일.
        use: ['css-loader'], // css-loader를 적용한다.
      },
    ],
  },
};
```

이제 웹팩은 모듈을 검색하다가 CSS 파일을 찾으면 css-loader로 처리하게 된다.

use.loader에 로더 경로를 설정하는 대신 배열에 로더 이름을 문자열로 전달해도 된다.

이제 `npm run build`를 하면 CSS가 자바스크립트로 변환된 것을 확인할 수 있다.

## 4.2. style-loader

모듈로 변경된 스타일 시트는 DOM에 추가되어야 브라우저가 해석할 수 있다.

css-loader로 처리하면 자바스크립트 코드로만 변경되었을 뿐 DOM에 적용되지 않았기 때문에 스타일이 적용되지 않는다.

**style-loader**는 **자바스크립트로 변경된 스타일을 동적으로 DOM에 추가하는 로더**이다.

> 🚨 중요 :CSS를 번들링하기 위해서는 css-loader와 style-loader를 함께 사용한다.

먼저 스타일 로더를 다운로드 한다.

```sh{}
$ npm install -D style-loader
```

그리고 웹팩 설정에 로더를 추가한다.

./package.json

```js{}
module.exports = {
  module: {
    rules: [
      {
        test: /\.css\$/,
        use: ['style-loader', 'css-loader'], // style-loader를 앞에 추가한다.
      },
    ],
  },
};
```

배열로 설정하면 ~뒤에서부터 앞으로 순서대로 로더가 동작~한다.

위 설정은 모든 .css 확장자로 끝나는 모듈을 읽어 들여 css-loader를 적용하고 그 다음 style-loader를 적용한다.

## 4.3. file-loader

소스코드에서 사용하는 모든 파일을 모듈로 사용하게 할 수 있다.

**파일을 모듈 형태로 지원하고 웹팩 아웃풋에 파일을 옮겨주는 것**이 **file-loader**가 하는 일이다.

예를 들어 CSS에서 url() 함수에 이미지 파일 경로를 지정할 수 있는데 웹팩은 file-loader를 이용해서 이 파일을 처리한다.

./style.css

```css{}
body {
  background-image: url(bg.png);
}
```

위에서 배경 이미지를 bg.png 파일로 지정했다.

웹팩은 엔트리 포인트인 app.js가 로딩하는 style.css 파일을 읽을 것이다.

그리고 이 스타일시트는 url() 함수로 bg.png를 사용하는데 이때 로더를 동작시킨다.

./webpack.config.js

```js{}
module.exports = {
  module: {
    rules: [
      {
        test: /\.png$/, // .png 확장자로 마치는 모든 파일.
        loader: 'file-loader', // 파일 로더를 적용한다.
      },
    ],
  },
};
```

웹팩이 .png 파일을 발견하면 file-loader를 실행할 것이다.

로더가 동작하고 나면 아웃풋에 설정한 경로로 이미지 파일을 복사된다.

파일명은 해쉬코드로 변경 되는데 이대로 index.html 파일을 브라우져에 로딩하면 이미지를 제대로 로딩하지 못할 것이다.

CSS를 로딩하면 background-image: url(bg.png) 코드에 의해 동일 폴더에서 이미지를 찾으려고 시도할 것이다.

그러나 웹팩으로 빌드한 이미지 파일은 output인 dist 폴더 아래로 이동했기 때문에 이미지 로딩에 실패할 것이다.

file-loader 옵션을 조정해서 경로를 바로 잡아 주어야 한다.

```js{}
module.exports = {
  module: {
    rules: [
      {
        test: /\.png$/, // .png 확장자로 마치는 모든 파일.
        loader: 'file-loader',
        options: {
          publicPath: './dist/', // prefix를 아웃풋 경로로 지정.
          name: '[name].[ext]?[hash]', // 파일명 형식.
        },
      },
    ],
  },
};
```

**publicPath** 옵션은 file-loader가 처리하는 파일을 모듈로 사용할 때 경로 앞에 추가되는 문자열이다.

output에 설정한 'dist' 폴더에 이미지 파일을 옮길 것이므로 publicPath 값을 이것으로로 지정했다.

파일을 사용하는 측에서는 'bg.png'를 'dist/bg.png'로 변경하여 사용할 것이다.

또한 name 옵션을 사용했는데 이것은 로더가 파일을 아웃풋에 복사할때 사용하는 파일 이름이다.

기본적으로 설정된 해쉬값을 쿼리스트링으로 옮겨서 'bg.png?6453a9c65953c5c28aa2130dd437bbde' 형식으로 파일을 요청하도록 변경했다.

이렇게 스타일시트에서 불러온 파일이 동작한다.

## 4.4. url-loader

사용하는 이미지 갯수가 많다면 네트웍 리소스를 사용하는 부담이 있고 사이트 성능에 영향을 줄 수도 있다.

만약 한 페이지에서 작은 이미지를 여러 개 사용한다면 Data URI Scheme을 이용하는 방법이 더 나은 경우도 있다.

이미지를 Base64로 인코딩하여 문자열 형태로 소스코드에 넣는 형식이다.

url-loader는 이러한 처리를 자동화해주는 녀석이다.

먼저 로더를 설치한다.

```sh{}
$ npm install -D url-loader
```

그리고 웹팩 설정을 추가한다.

./webpack.config.js

```js{}
{
  test: /\.png$/,
  use: {
    loader: 'url-loader', // url 로더를 설정한다.
    options: {
      publicPath: './dist/', // file-loader와 동일.
      name: '[name].[ext]?[hash]', // file-loader와 동일.
      limit: 5000 // 5kb 미만 파일만 data url로 처리.
    }
  }
}
```

file-loader와 옵션 설정이 거의 비슷하고 마지막 limit 속성만 추가했다.

모듈로 사용한 파일중 크기가 5kb 미만인 파일만 url-loader를 적용하는 설정이다.

만약 이보다 크면 file-loader가 처리하는데 옵션 중 fallback 기본값이 file-loader이기 때문이다.

빌드 결과를 보면 small.png 파일이 문자열로 변경되어 있는 것을 확인 할 수 있다.

반면 5kb 이상인 bg.png는 여전히 파일로 존재한다.

브라우저에서도 확인하면 스타일스트에 small.png가 Data url형태로 변환되어 있다.

아이콘처럼 용량이 작거나 사용 빈도가 높은 이미지는 파일을 그대로 사용하기 보다는 Data URI Scheeme을 적용하기 위해 url-loader를 사용하는 것을 권장한다.

# 5. 플러그인

## 5.1. 플러그인의 역할

## 5.2. 커스텀 플러그인 만들기

# 6. 자주 사용하는 플러그인

## 6.1. BannerPlugin

## 6.2. DefinePlugin

## 6.3. HtmlWebpackPlugin

## 6.4. CleanWebpackPlugin

## 6.5. MiniCssExtractPlugin

# 7. 참조 📋

- [김정환님 블로그](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)
- [인프런 - 프론트엔드 개발환경의 이해와 실습](https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD)

👋
