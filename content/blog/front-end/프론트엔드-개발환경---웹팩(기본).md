---
title: 프론트엔드 개발환경 - 웹팩(기본)
date: 2020-09-08 10:09:08
category: front-end
thumbnail: './images/200908-webpack-icon.png'
draft: true
---

![](./images/200908-webpack-icon.png)

프론트엔드 개발환경 - 웹팩(기본)

> `정보` : [**김정환**](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)님의 [프론트엔드 개발환경의 이해와 실습](https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD)을 공부하고 정리한 내용.

# 1. 배경 🚀

Javascript로 개발을 할 때 모듈의 필요성과 한계가 나타나고 그에 따라 웹팩(Webpack)이 등장하게 되었다.

```js{}
function sum(a, b) {
  return a + b;
} // 전역 공간에 sum이 노출

sum(1, 2); // 결과는 3

sum = 3;
sum(1, 2); // Uncaught TypeError: sum is not a function
```

상단처럼 전역(Global)에서 설정된 변수의 내용이 임의로 변하는 것을 막기 위한 방법이 필요했다.

## 1.1. IIFE 방식의 모듈

[IIFE](https://developer.mozilla.org/ko/docs/Glossary/IIFE)(즉시 실행 함수 표현)는 즉시 함수를 실행하여 외부에서 접근을 막는 함수이다.

```js{}
var math = math || {}; // math 네임스페이스

(function () {
  function sum(a, b) {
    return a + b;
  }
  math.sum = sum; // 네이스페이스에 추가
})();

math.sum(1, 2); // 결과는 3

sum(1, 2); // Uncaught TypeError: sum is not a function
```

## 1.2. 다양한 모듈 스펙

자바스크립트의 모듈을 구현하는 대표적인 명세는 [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)와 [CommonJS](http://www.commonjs.org)가 있다.

그리고 ES2015에서 [표준 모듈 시스템](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)이 나오게 되었다.

./math.js

```js{}
export function sum(a, b) {
  return a + b;
}
```

./app.js

```js{}
import * as math from './math.js';
math.sum(1, 2); // 3
```

문제는 모든 브라우저에서 이 모듈 기능을 지원하지 않는다는 것이다 😱.

# 2. 웹팩(Webpack) 📦

웹팩은 여러개의 파일을 하나로 합쳐주는 번들러(bundler)다.

그럼 webpack을 설치해보자.

```sh{}
$ npm install -D webpack webpack-cli
```

webpack을 설치한 후에 옵션을 보자.

```sh{}
# node_modules/.bin/webpack --help를 입력하면 정보를 알 수 있다.
$ node_modules/.bin/webpack --help

  --mode                 Enable production optimizations or development hints.
                                     [선택: "development", "production", "none"]
  --entry      The entry point(s) of the compilation.                   [문자열]
  --output, -o                  The output path and file for compilation assets
```

여기서 `--mode`, `--entry`, `--output` 세 개 옵션만 사용하면 코드를 묶을 수 있다.

```sh{}
$ node_modules/.bin/webpack --mode development --entry ./src/app.js --output dist/main.js
```

- `--mode`는 웹팩 실행 모드는 의미하는데 개발 버전인 development를 지정한다.
- `--entry`는 시작점 경로를 지정하는 옵션이다.
- `--output`은 번들링 결과물을 위치할 경로다.

위 명령어를 실행하면 dist/main.js에 번들된 결과가 저장된다.

```sh{}
> lecture-frontend-dev-env@1.0.0 build /Users/davidyang/Documents/lecture-frontend-dev-env
> webpack

Hash: 5610665b6c989a4f05ee
Version: webpack 4.44.1
Time: 97ms
Built at: 2020-09-08 16:04:38
  Asset      Size  Chunks             Chunk Names
main.js  19.9 KiB    main  [emitted]  main
Entrypoint main = main.js
[./src/app.js] 145 bytes {main} [built]
```

그리고 index.html에 로딩하면 번들링의 결과와 동일하게 된다.

```html{}
<script src="dist/main.js"></script>
```

또한 `webpack.config.js`를 생성해 사용할 수 있다.

```js{}
const path = require('path');

module.exports = {
  mode: 'development',
  entry: {
    main: './src/app.js',
  },
  output: {
    filename: '[name].js',
    path: path.resolve('./dist'),
  },
};
```

그리고 `package.json`에 명령어를 추가한다.

```json{}
{
  "scripts": {
    "build": "./node_modules/.bin/webpack"
    //"build": "webpack" // 이렇게 해도 된다.
  }
}
```

이제 터미널에 **npm run build**로 webpack을 실행할 수 있다.

```sh{}
$ npm run build
```

이후 마찬가지로 index.html에 로딩하면 된다.

# 3. 로더 🔋

웹팩은 모든 파일을 모듈로 관리하는데 이미지, 폰트, 스타일시트도 모두 모듈로 관리한다.

웹팩은 자바스크립트 밖에 인식할 수 없기 때문에 이미지, 폰트, 스타일시트를 웹팩이 이해할 수 있도록 변경시켜야 한다.

로더가 바로 이 역할을 한다.

## 3.1. 로더의 역할

로더는 타입스크립트 같은 다른 언어를 자바스크립트 문법으로 변환해 주거나 이미지를 data URL 형식의 문자열로 변환한다.

뿐만아니라 CSS 파일을 자바스크립트에서 직접 로딩할수 있도록 해준다.

## 3.2. 커스텀 로더 만들기

커스텀으로 로더를 만들어 보자.

./myloader.js

```js{}
module.exports = function myloader(content) {
  console.log('myloader 테스트');
  return content;
};
```

커스텀 로더를 제작한 후에 웹팩 설정파일의 module 객체에 추가한다.

./webpack.config.js

```js{}
module: {
  rules: [{
    test: /\.js$/, // .js 확장자로 끝나는 모든 파일.
    use: [path.resolve('./myloader.js')] // 방금 만든 로더를 적용한다.
  }],
}
```

module.rules 배열에 모듈을 추가하는데 test와 use로 구성된 객체를 전달한다.

test에는 로딩에 적용할 파일을 지정한다.

use에는 패턴에 해당하는 파일에 적용할 로더를 설정하는 부분으로 방금 만든 myloader 함수의 경로를 지정한다.

`npm run build`을 실행해보자.

```sh{}
$ npm run build

> lecture-frontend-dev-env@1.0.0 build /Users/davidyang/Documents/lecture-frontend-dev-env
> webpack

myloader 테스트
Hash: 5610665b6c989a4f05ee
Version: webpack 4.44.1
Time: 115ms
Built at: 2020-09-09 23:16:09
  Asset      Size  Chunks             Chunk Names
main.js  19.9 KiB    main  [emitted]  main
Entrypoint main = main.js
[./src/app.js] 145 bytes {main} [built]
```

터미널에 myloader 테스트' 문자열이 찍힌다.

myloader() 함수가 동작했다.

# 4. 자주 사용하는 로더

자주 사용하는 로더를 확인해보자.

## 4.1. css-loader

웹팩에 css-loader를 추가하여 모듈로 변환한다.

./app.js

```js{}
import './style.css';
```

./style.css

```css{}
body {
  background-color: green;
}
```

CSS 파일을 자바스크립트에서 불러와 사용할 수 있게 CSS를 모듈로 변환해보자.

css-loader를 설치하자.

```sh{}
npm install -D css-loader
```

웹팩 설정에 로더를 추가한다.

./webpack.config.js:

```js{}
module.exports = {
  module: {
    rules: [
      {
        test: /\.css\$/, // .css 확장자로 끝나는 모든 파일.
        use: ['css-loader'], // css-loader를 적용한다.
      },
    ],
  },
};
```

이제 웹팩은 모듈을 검색하다가 CSS 파일을 찾으면 css-loader로 처리하게 된다.

use.loader에 로더 경로를 설정하는 대신 배열에 로더 이름을 문자열로 전달해도 된다.

이제 `npm run build`를 하면 CSS가 자바스크립트로 변환된 것을 확인할 수 있다.

## 4.2. style-loader

## 4.3. file-loader

## 4.4. url-loader

# 5. 플러그인

## 5.1. 플러그인의 역할

## 5.2. 커스텀 플러그인 만들기

# 6. 자주 사용하는 플러그인

## 6.1. BannerPlugin

## 6.2. DefinePlugin

## 6.3. HtmlWebpackPlugin

## 6.4. CleanWebpackPlugin

## 6.5. MiniCssExtractPlugin

# 7. 참조 📋

- [김정환님 블로그](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)
- [인프런 - 프론트엔드 개발환경의 이해와 실습](https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD)

👋
