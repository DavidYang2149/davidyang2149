---
title: Chapter 2. 고계 자바스크립트
date: 2020-11-25 06:11:81
category: javascript
thumbnail: './images/javascript.png'
draft: true
---

![](./images/javascript.png)

> `정보` : **'함수형 자바스크립트'** 스터디

# 2. 고계 자바스크립트

자바스크립트가 함수형 언어로서 손색이 없는 이유와 그럼에도 미흡한 점을 설명.

## 2.1 왜 자바스크립트인가? 🚀

- 왜 자바스크립트인가?

  - 편재성(어디에나 있음).
  - 동적 형식(다양한 타입을 선언).

- 자바스크립트는 계속 진화하고 개선 중
  - ES6 이후 화살표 함수, 상수, 이터레이터, 프라미스 등 함수형 프로그래밍에 걸맞은 기능이 추가 됨.

## 2.2 함수형 대 객체지향 프로그래밍

|                   |              함수형               |               객체지향형               |
| :---------------: | :-------------------------------: | :------------------------------------: |
|     합성 단위     |               함수                |              객체(클래스)              |
| 프로그래밍 스타일 |              선언적               |                 명령형                 |
|   데이터와 기능   | 독립적인 순수함수가 느슨하게 결합 |   클래스 안에서 메서드와 단단히 결합   |
|     상태 관리     |      객체를 불변 값으로 취급      | 인스턴스 메서드를 통해 객체를 변이시킴 |
|     제어 흐름     |            함수와 재귀            |            루프와 조건 분기            |
|      스레드       |    안전 동시성 프로그래밍 가능    |           캡슐화하기 어려움            |
|      캡슐화       |   모든 것이 불변이라 필요 없음    |   데이터 무결성을 지키기 위해 필요함   |

### 2.2.1 자바스크립트 객체의 상태 관리

- 상태는 어느 한 시점에 찍은 모든 객체에 저장된 **데이터의 스냅샷**이다.
- 자바스크립트는 객체 상태를 보호하는 측면에서 최악의 언어.
- 불변성을 관리하기 위해 지침과 패턴을 잘 지켜야한다(사용자의 책임 강조).

### 2.2.2 객체를 값으로 취급

- const를 사용

  - 값을 재할당하거나 레퍼런스를 다시 선언할 수 없음.
  - FP가 요구하는 수준의 불변성을 실현하기는 어려움 => 객체의 내부값 변경이 허용됨.

- ## 값 객체 패턴

👋

스터디
1장 2장의 중요한 개념을 다룬다.
핵심 개론들

## 함수형 프로그래밍란 무엇인가?

- 부수효과가 없는 함수로 프로그래밍을 하는 것을 함수형 프로그래밍이라고 한다.
- 함수로 기능을 추상화해서 프로그래밍하는 것.
- 이미 입증된 함수를 새로운 함수를 만들어서 프로그래밍하는 것.
- 상태변이를 최소화하면서 프로그래밍을 하는 것.

## 부수효과가 없다는 것은 무엇인가?

- 변수를 변경한다던가 객체가 변하지 않는 것
- 순수함수다.
- 외부 변수에 의존하지 않는다.
- 외부에 의해 영향을 받지 않는다.

정리하자면

- 부수 효과는 효과가 아닌 것.

## 효과란?

- 함수의 반환값에 의해서만 변경이 일어나는 것.

### 예시

예시로 설명할 수 있어야 한다.

```js
// 부수효과가 없음
const sum = (a, b) => a + b;

// 부수효과가 발생
let other;

const sum = (a, b) => {
  other = a + b;
};
```

## 함수형 프로그래밍은 왜 해야할까?

- 복잡한 코드를 간결하게 분리할 수 있다.
- 테스트가 용이하다.
- 선언적으로 할 수 있다.
- 더 안전하게 프로그래밍할 수 있다.
- 순수한 부분과 순수하지 않은 부분을 명확하게 나눌 수 있다.

개인 궁금 : 상태변이는 무엇이과 부수효과는 무엇인가?
에러가 발생하면 바깥으로 던지고 센트리를 이용하여 에러를 수집하게 해야한다.

## 선언형 프로그래밍이란?

- 무엇(What)에 집중하는 것
- 결과만 기술할 뿐 어떻게는 기술하지 않는 방법
- 의도에 집중하는 프로그래밍 방법

map, reduce, filter를 명령형으로 제작해보면 함수형의 장점을 느낄 수 있다.

## 함수란 무엇인가?

- 방정식 1 + 2 = 3이다. 같은 파라미터는 같은 결과가 나온다.

## 함수형 프로그래밍의 특징은 무엇일까?

- 부수효과를 최소화한다.
- 선언적으로 한다.
- 결합도가 약해서

### Value Object 패턴이란 무엇일까?

- 객체를 값으로
- 변하지 않는 값을 취급한다.
- 값을 변화시키지 않는다.

- 값인데, 내부의 값이 바뀌면 그 값을 구분할 수 없는 변수를 value Object라고 한다.
- Entity Identifer(식별자)
- 오직 값에 좌우되는 객체

Tip. Value Object 패턴 같은 생소한 용어는 그냥 넘어가지 않고 꼭 확인하고 가야한다.

## 참조 투명성이란 무엇일까?

- 함수를 값으로 대체할 수 있는 것(치환모델).

Q. 참조 투명성을 찾아보자.

```js
const sum = (a + b) => {
  return a + b;
};

sum(3, 4);
```

## 커링이란 무엇일까?

- 인자가 여러개를 받는 함수를 인자 하나씩만 받도록 만드는 것.

## 단항함수

- 인자를 하나만 받는 함수.

## 커링을 적용한 함수는?

-

## 커링을 왜 할까?

- 파라미터가 하나인 함수를 만들기 위해서
- 매개변수의 처리에 대한 책임을 나누기 위해서
- 중간과정에 개입할 수 있는 여지를 만들 수 있다.

- 값을 여러개를 받는 함수가 있는데 매번 입력하기 힘든데 쪼개기 위해서
- 함수를 쪼개서 유연하게 사용할 수 있도록
- 단일 책임의 원칙을 지킬 수 있다.
- 가장 큰 이유: 매개변수가 하나인 함수를 만들기 위해서이다.

```js
const arr = ['1', '2', '3'];

const curriedParseInt = (radix) => (value) => parseInt(value, radix);

const toDecimal = curriedParseInt(10);
const toHex = curriedParseInt(16);

arr.map((it) => {
  return parseInt(it, 10);
});
```

## 부분 적용 함수란?

- 일부가

```js
const arr = ['1', '2', '3'];

const curriedParseInt = (radix) => (value) => parseInt(value, radix);

const toDecimal = curriedParseInt(10);

// 여기서 curriedParseInt(10)는 (value) => parseInt(value, 10)의 상태인 것을 부분 적용 함수라고 한다.
```

## 함수형/객체지향은 어떤 차이가 있는가?

- 객체지향은 데이터와 기능이 깊게 결합되어 있다.

- 함수는 데이터와 기능을 느슨하게 연결한다.
- 상태와 기능을 철저히 분리한 다음 이들을 다시 조합한 새로운 함수로 연산을 추가할 수 있다.
- 문제들을 작은 함수로 잘게 나눈다.

- 객체지향형과 함수형의 차이는 무엇인가?
- 의견은 본질적으로 같아진다고 모아짐.
  (참조 - 함수형 프로그래밍과 객체지향형의 차이)
  FP와 OOP가 전혀 다른 패러다임이라는 사고방식은 객체를 정의하는 전통적인 방향 때문에 생긴 오해인듯 싶다며. 객체는 상태와 동작을 묶은 캡슐이라는 기존의 시각에선.. 함수도 객체라는 관점이 성립하기 어려워지니까. 그러나 실제로 함수는 객체와 전혀 다른 무엇이 아니라, “상태가 없는 객체”라는 관점으로 보는 것이 적절하다며. 따라서 객체 = 상태 + 동작이라는 시각이 수정된다면.. FP는 단지 동작만 갖고 있는 객체의 조합을 통해 코딩하는 방식으로 정의되어 OOP속으로 들어오게 된다고 말할 수 있게 된다며. 상태없이 동작만 있는 ADT만으로 객체 구성원들이 모두 표현이 된다면 ‘상태변이’라는 변수를 추적해야하는 기존 OOP가 갖고 있는 고질적인 문제에서 조금 더 예측하기 쉬운 코드로 표현되는 OOP로 개선될 수 있는데 이점을 그냥 FP라고 부를 뿐이람서. FP와 OOP는 패러다임이 다른 것이 아니라 모델이 다를 뿐이라며.
  (참조: 함수형 프로그래밍이란 무엇인가 번역)
  https://medium.com/@jooyunghan/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-fab4e960d263

lodash 사용을 권장.

책 추천 - 수학 리부트 : http://www.yes24.com/Product/Goods/90750959
책 추천 - 어떻게 공부할 것인가 : http://www.yes24.com/Product/Goods/15341766

- 스터디 깃허브 https://github.com/CodeSoom/functional-javascript

다음주는 코드를 한번씩 처보기
질문이 있으면 미리 올려보기

## High order function란 무엇일까?

## first class(일급 시민)이라는 것은 무엇일까?

## 클로저란 무엇일까?

const getName = (person)


## 3장

### 제어흐름이란?
프로그램의 정답에까지 거치는 경로

### 명령형 프로그램과 함수형 프로그래밍이 어떻게 다른가?

명령형 프로그램과 무엇을 할지 세세하게 지정한다. 예를 들어 분기를 한다면 각 조건에 따라 나누어주어야 한다.

함수형 프로그래밍은 어떻게 보다는 무엇을 할지에 대해 나열하는 프로그래밍이다.

제어 흐름을 서술적으로 보여준다.

어떻게 서술하는지에 차이가 있다. 예를 들어 

## 메서드란 무엇인가?

어떤 객체가 할 수 있는 행위를 메서드라고 한다.
### 메서드 체이닝이란?

여러개의 메소드를 하나의 expression으로 연결하는 것.

### 함수 체이닝이란?

작업을 수행하기 위해 무슨일을 해야 하는지 기술된 함수를 인수로 받는다.
자료구조를 새로 만들어 어떤 요건을 충족시키는 것이 아니라, 배열 등 흔한 자료구조를 
이용해 다수의 굵게 나눈 고계연수를 적용한다.


함수를 반환하고 이어서 다른 함수를 실행하는 것?
함수를 연결하는 것?

```js
['a', 'b', 'c', null]
  .filter((it) => it)
  .map((it) => it.toUpperCase());

```

### 재귀적인 사고 방식이란?

반복적인 연산에서 자기 자신 또는 변형한 버전을 생각하는 것.


점화식

어떤 연산을 하고자 했을 때 반복적인 연산을 표현하는데 계속 순환되는 반복.

자기자신을 계속 실행해 보는 것.

재귀적인 사고란? 자기 자신 또는 변형한 버전을 생각하는 것.

예제

```js
const numbers = [1, 2, 3, 4, 5];

let sum = 0;

for (let i = 0; numbers.length; i++) {
  sum += numbers[i];
}

console.log(sum); // 15

```

재귀적인 사고방식
```
1 + [2, 3, 4, 5];
1 + 2 + [3, 4, 5];
1 + 2 + 3 + [4, 5];
1 + 2 + 3 + 4 + 5 + [];
15;
```

### 어떻게 반복적인 문제들로 잘게 분해할 수 있는가?

* base case (320 번째 줄)
* recursive case (321 번째 줄)

```hs
sum :: [Int] -> Int
sum [] = 0
sum (x:xs) = x + sum xs

```

꼬리재귀호출 최적화를 알지 않는다면 효율성이 떨어진다.

### 꼬리 호출 최적화

```
1 + sum[2, 3, 4, 5]
(1 + 2) + sum[3, 4, 5]
(1 + 2 + 3) + sum[4, 5]
(1 + 2 + 3 + 4) + sum[5]
(1 + 2 + 3 + 4 + 5) + sum[]
```

```js
// 재귀
const sum = (number, numbers) => {
  if (numbers.isEmpty()) {
    return 0;
  }

  // 1 + sum[2, 3, 4, 5] => 스택에 쌓아놓음
  // (1 + 2) + sum[3, 4, 5] => 스택에 쌓아놓음
  // (1 + 2 + 3) + sum[4, 5] => 스택에 쌓아놓음
  // (1 + 2 + 3 + 4) + sum[5] => 스택에 쌓아놓음
  // (1 + 2 + 3 + 4 + 5) + sum[] => 스택에 쌓아놓음
  return first(numbers) + drop(numbers);
}

// 꼬리 재귀 => 무조건 반복문으로 변경 가능 => 
const sum = (numbers, sum = 0) => {
  if (numbers.isEmpty()) {
    return sum;
  }

  // sum([2, 3, 4, 5], 0 + 1) => 다음과정이 끝나면 사라짐
  // sum([3, 4, 5], 1 + 2) => 또 다음과정이 끝나면 사라짐
  // 스택이 2개만 유지됨 => 콜스택 터짐이 없다.
  return sum(drop(numbers), sum + first(numbers));
}
```

### 추상황 수준이 높다는 것은 무엇을 의미하는가?

```js
isEmpty = (arr) => {
  if (arr === undefined) {
    return true;
  }

  if (arr === null) {
    return true;
  }

  arr.length === 0;
}
```

```js
if (resturants.length === 0) {
    return 비어있다;
  }
```

### 수동 루프를 왜 없애야 하는가?

재사용하기 어렵다.
더 명시적이고 의도가 더 잘 들어나는 것이 있기 때문이다.

### reduce, map, filter란?

별도

### lazy한 프로그램이란 무엇인가?

별도

### 챕터 4

### 파이프라인이란 무엇인가?

함수가 변환이 되면 리턴한 변수를 함수가 받아서 함수 체이닝의 또다른 방법이다.

```
flow(
  handleMessageError,
  handleVaildationError,
  handleUnexpectedError,
)
```

### 체이닝이란?

### 덕타이핑에 대해서

오리처럼 행동하면 오리다.

golang은 인터페이스가 없지만 
### 함수의 인수를 적게 해야하는 이유

### 튜플이란 무엇인가? 함수간 데이터를 변환할 때 튜플이 좋은 이유는?

만들어 놓으면 그 다음부터는 바꿀 수 없는 key, value 자료형.
매개변수가 하나이지만 여러개의 값을 받아야할 때 사용.

### 커리된 커리되지 않은 함수를 어떻게 구분할 수 있는가.

커리된 함수는 모자란 매개변수가 비어있는 새로운 함수이다.
여러개의 매개변수를 받는 함수를, 매개변수를 하나만 받도록 쪼개는데, 객 매개변수를 넣으면 매개변수가 
부분적용된 새로운 함수를 반환한다.
커리되지 않은 함수는 모자란 매개변수가 nudefined이다.
### 부분적용이란 무엇인가



### 함수 합성이란 무엇인가?

함수 하나의 반환값을 다른 함수의 입력값으로 쓰는 것.

### 