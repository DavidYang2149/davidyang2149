---
title: comment-test
date: 2020-08-04 10:08:24
category: test
draft: true
---

코멘트 테스트용 글입니다.

2020-08-04 기준 댓글 정상 작동 확인.

# h1 테스트

TOC 내용 테스트

## h2 테스트

TOC 내용 테스트

### h3 테스트

TOC 내용 테스트

#### h4 테스트

TOC 내용 테스트

##### h5 테스트

TOC 내용 테스트

###### h6 테스트

TOC 내용 테스트

의문점
tip1.

- Q. const의 배열이나 객체의 경우 값이 변할 수 있는데도 사용하는 이유가 무엇인가?
- A. 선언시에 객체나 배열로 설정하고 그 틀을 변경하지 않게 하기 위해서이다.
- A. 추가적으로 immer.js나 immutable.js는 배열이 변경이 안되도록 고정시킬 수 있다.

tip2.

- Q. 값을 조작하지 않고 작성하는 것이 무엇인가?
- A. 배열의 filter는 값을 조작하지 않고 새롭게 선언한다(?).

tip3.

- Q. 블록 충돌을 어떻게 해결할 것인가?
- 즉시실행, 렉시컬 스코프 고려

tip4.

- Q. 장점?
- A. 간단하고 명료하다. 수정이 쉽다.

tip5.

- Q. 배열을 컬렉션으로 바꾸기 쉽고 반대도 가능한데 이점은?
- A. 배열에서 컬렉션 / 컬렉션에서 배열로 변환을 할 때 변환 처리의 복잡성이 낮아진다.
- Q. == 과 === 차이
- A. == 일 떄 형변환 작업이 들어가기 떄문에 === 보다 더 많은 자원이 소모된다.
- Q. Object.entries()를 사용하는 이유?
- A. ???

tip6.

- Q. includes를 사용하는 이유
- A. indexOf를 사용할 경우 위치가 0이면 0이 false로 변환될 수 있기 때문인다.

tip7.

- Q. spread syntax가 더 정확한 표현이 아닐까...
- A.

tip8.

- Q. spread syntax가 가지는 의미는...
- A. 전달한 값을 변경하지 않을 것이라는 신뢰를 주는 것이다.
- Q. 함수의 인자를 건드리지 말아야한다. (예시가 removeItem() 함수...)
- A.

tip9.

- Q. sort, reverse, pop, push, spread 는 원본을 건드릴 수 있으므로 spread xyntax로 접근하자.
- A.

3분 읽기

tip10.

- Q. 배열은 인덱스로 순서대로 접근이 가능하고 객체는 다른 속성의 집합을 접근할 수 있다.
- 객체를 이용해서 정적, 키값

추가

- value object의 경우 항상 immutable로 관리해야 한다.
- entity는 값이 변경될 수 있다.
